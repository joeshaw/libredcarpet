// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace RC {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class PackageDep : GLib.Opaque {

		[DllImport("libredcarpet")]
		static extern bool rc_package_dep_is_or(IntPtr raw);

		public bool IsOr { 
			get {
				bool raw_ret = rc_package_dep_is_or(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_package_dep_slist_copy(IntPtr list);

		public static GLib.SList SlistCopy(GLib.SList list) {
			IntPtr raw_ret = rc_package_dep_slist_copy(list.Handle);
			GLib.SList ret = new GLib.SList(raw_ret);
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern int rc_package_dep_get_relation(IntPtr raw);

		public RC.PackageRelation Relation { 
			get {
				int raw_ret = rc_package_dep_get_relation(Handle);
				RC.PackageRelation ret = (RC.PackageRelation) raw_ret;
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern void rc_package_dep_spew_cache();

		public static void SpewCache() {
			rc_package_dep_spew_cache();
		}

		[DllImport("libredcarpet")]
		static extern bool rc_package_dep_is_pre(IntPtr raw);

		public bool IsPre { 
			get {
				bool raw_ret = rc_package_dep_is_pre(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern void rc_package_dep_slist_free(IntPtr list);

		public static void SlistFree(GLib.SList list) {
			rc_package_dep_slist_free(list.Handle);
		}

		[DllImport("libredcarpet")]
		static extern bool rc_package_dep_verify_relation(IntPtr packman, IntPtr dep, IntPtr prov);

		public static bool VerifyRelation(RC.Packman packman, RC.PackageDep dep, RC.PackageDep prov) {
			bool raw_ret = rc_package_dep_verify_relation(packman == null ? IntPtr.Zero : packman.Handle, dep == null ? IntPtr.Zero : dep.Handle, prov == null ? IntPtr.Zero : prov.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_package_dep_get_channel(IntPtr raw);

		public RC.Channel Channel { 
			get {
				IntPtr raw_ret = rc_package_dep_get_channel(Handle);
				RC.Channel ret = raw_ret == IntPtr.Zero ? null : (RC.Channel) GLib.Opaque.GetOpaque (raw_ret, typeof (RC.Channel), false);
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_package_dep_to_string(IntPtr raw);

		public override string ToString() {
			IntPtr raw_ret = rc_package_dep_to_string(Handle);
			string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
			return ret;
		}

		public PackageDep(IntPtr raw) : base(raw) {}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_package_dep_new(IntPtr name, bool has_epoch, uint epoch, IntPtr version, IntPtr release, int relation, IntPtr channel, bool pre, bool is_or);

		public PackageDep (string name, bool has_epoch, uint epoch, string version, string release, RC.PackageRelation relation, RC.Channel channel, bool pre, bool is_or) 
		{
			IntPtr name_as_native = GLib.Marshaller.StringToPtrGStrdup (name);
			IntPtr version_as_native = GLib.Marshaller.StringToPtrGStrdup (version);
			IntPtr release_as_native = GLib.Marshaller.StringToPtrGStrdup (release);
			Raw = rc_package_dep_new(name_as_native, has_epoch, epoch, version_as_native, release_as_native, (int) relation, channel == null ? IntPtr.Zero : channel.Handle, pre, is_or);
			GLib.Marshaller.Free (name_as_native);
			GLib.Marshaller.Free (version_as_native);
			GLib.Marshaller.Free (release_as_native);
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_package_dep_new_from_spec(IntPtr spec, int relation, IntPtr channel, bool pre, bool is_or);

		public PackageDep (RC.PackageSpec spec, RC.PackageRelation relation, RC.Channel channel, bool pre, bool is_or) 
		{
			Raw = rc_package_dep_new_from_spec(spec.Handle, (int) relation, channel == null ? IntPtr.Zero : channel.Handle, pre, is_or);
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_package_dep_ref(IntPtr raw);

		protected override void Ref (IntPtr raw)
		{
			if (!Owned) {
				rc_package_dep_ref (raw);
				Owned = true;
			}
		}

		[DllImport("libredcarpet")]
		static extern void rc_package_dep_unref(IntPtr raw);

		protected override void Unref (IntPtr raw)
		{
			if (Owned) {
				rc_package_dep_unref (raw);
				Owned = false;
			}
		}

#endregion
#region Customized extensions
#line 1 "PackageDep.custom"
/* -*- Mode: csharp; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
//{
    public RC.PackageSpec Spec {
        get { return new RC.PackageSpec (Handle); }
    }

    internal static GLib.SList ToSList (PackageDep[] deps) {
        GLib.SList ret = new GLib.SList (typeof (PackageDep));
        foreach (PackageDep d in deps)
            ret.Append (d.Handle);

        return ret;
    }

    public void ToXml (System.Xml.XmlTextWriter writer)
    {
        // FIXME: if (this.IsOr) rc_package_dep_or_slist_to_xml_node ()

        writer.WriteStartElement ("dep");

		using (RC.PackageSpec spec = Spec) {
			writer.WriteAttributeString ("name", spec.Name);

			if (this.Relation != PackageRelation.Any) {
				writer.WriteAttributeString ("op", Package.RelationToString (this.Relation, 0));

				if (spec.HasEpoch)
					writer.WriteAttributeString ("epoch", System.Xml.XmlConvert.ToString (spec.Epoch));

				if (spec.Version != null)
					writer.WriteAttributeString ("version", spec.Version);

				if (spec.Release != null)
					writer.WriteAttributeString ("release", spec.Release);
			}
		}

        writer.WriteEndElement ();
    }

    private void ParseXmlNode (System.Xml.XmlTextReader reader)
    {
        string name = null;
        string version = null;
        string release = null;
        bool has_epoch = false;
        uint epoch = 0;
        RC.PackageRelation relation = PackageRelation.Any;
        RC.Channel channel = Channel.ANY;

        name = reader["name"];

        string tmp = reader["op"];
        if (tmp != null) {
            relation = Package.RelationFromString (tmp);
            version = reader["version"];
            release = reader["release"];

            tmp = reader["epoch"];
            if (tmp != null) {
                has_epoch = true;
                epoch = System.Xml.XmlConvert.ToUInt32 (tmp);
            }
        }

        IntPtr name_as_native = GLib.Marshaller.StringToPtrGStrdup (name);
        IntPtr version_as_native = GLib.Marshaller.StringToPtrGStrdup (version);
        IntPtr release_as_native = GLib.Marshaller.StringToPtrGStrdup (release);
        Raw = rc_package_dep_new (name_as_native, has_epoch, epoch,
                                  version_as_native, release_as_native,
                                  (int) relation, channel.Handle, false, false);
        GLib.Marshaller.Free (name_as_native);
        GLib.Marshaller.Free (version_as_native);
        GLib.Marshaller.Free (release_as_native);
    }

    public PackageDep (System.Xml.XmlTextReader reader) {
        if (reader.LocalName == "dep") {
            ParseXmlNode (reader);
            // FIXME
            // } else if (node.Name == "or") {
        } else
            throw new ArgumentException ("Invalid XML node");
    }


#endregion
	}
}
