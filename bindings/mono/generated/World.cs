// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace RC {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public  class World : GLib.Object {

		~World()
		{
			Dispose();
		}

		[Obsolete]
		protected World(GLib.GType gtype) : base(gtype) {}
		public World(IntPtr raw) : base(raw) {}

		protected World() : base(IntPtr.Zero)
		{
			CreateNativeObject (new string [0], new GLib.Value [0]);
		}

		[GLib.CDeclCallback]
		delegate void ChangedChannelsVMDelegate (IntPtr arg1);

		static ChangedChannelsVMDelegate ChangedChannelsVMCallback;

		static void changedchannels_cb (IntPtr arg1)
		{
			World arg1_managed = GLib.Object.GetObject (arg1, false) as World;
			arg1_managed.OnChangedChannels ();
		}

		private static void OverrideChangedChannels (GLib.GType gtype)
		{
			if (ChangedChannelsVMCallback == null)
				ChangedChannelsVMCallback = new ChangedChannelsVMDelegate (changedchannels_cb);
			OverrideVirtualMethod (gtype, "changed_channels", ChangedChannelsVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(RC.World), ConnectionMethod="OverrideChangedChannels")]
		protected virtual void OnChangedChannels ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("changed_channels")]
		public event System.EventHandler ChangedChannels {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed_channels");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed_channels");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void ChangedSubscriptionsVMDelegate (IntPtr arg1);

		static ChangedSubscriptionsVMDelegate ChangedSubscriptionsVMCallback;

		static void changedsubscriptions_cb (IntPtr arg1)
		{
			World arg1_managed = GLib.Object.GetObject (arg1, false) as World;
			arg1_managed.OnChangedSubscriptions ();
		}

		private static void OverrideChangedSubscriptions (GLib.GType gtype)
		{
			if (ChangedSubscriptionsVMCallback == null)
				ChangedSubscriptionsVMCallback = new ChangedSubscriptionsVMDelegate (changedsubscriptions_cb);
			OverrideVirtualMethod (gtype, "changed_subscriptions", ChangedSubscriptionsVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(RC.World), ConnectionMethod="OverrideChangedSubscriptions")]
		protected virtual void OnChangedSubscriptions ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("changed_subscriptions")]
		public event System.EventHandler ChangedSubscriptions {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed_subscriptions");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed_subscriptions");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void ChangedLocksVMDelegate (IntPtr arg1);

		static ChangedLocksVMDelegate ChangedLocksVMCallback;

		static void changedlocks_cb (IntPtr arg1)
		{
			World arg1_managed = GLib.Object.GetObject (arg1, false) as World;
			arg1_managed.OnChangedLocks ();
		}

		private static void OverrideChangedLocks (GLib.GType gtype)
		{
			if (ChangedLocksVMCallback == null)
				ChangedLocksVMCallback = new ChangedLocksVMDelegate (changedlocks_cb);
			OverrideVirtualMethod (gtype, "changed_locks", ChangedLocksVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(RC.World), ConnectionMethod="OverrideChangedLocks")]
		protected virtual void OnChangedLocks ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("changed_locks")]
		public event System.EventHandler ChangedLocks {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed_locks");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed_locks");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void ChangedPackagesVMDelegate (IntPtr arg1);

		static ChangedPackagesVMDelegate ChangedPackagesVMCallback;

		static void changedpackages_cb (IntPtr arg1)
		{
			World arg1_managed = GLib.Object.GetObject (arg1, false) as World;
			arg1_managed.OnChangedPackages ();
		}

		private static void OverrideChangedPackages (GLib.GType gtype)
		{
			if (ChangedPackagesVMCallback == null)
				ChangedPackagesVMCallback = new ChangedPackagesVMDelegate (changedpackages_cb);
			OverrideVirtualMethod (gtype, "changed_packages", ChangedPackagesVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(RC.World), ConnectionMethod="OverrideChangedPackages")]
		protected virtual void OnChangedPackages ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("changed_packages")]
		public event System.EventHandler ChangedPackages {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed_packages");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "changed_packages");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void RefreshedVMDelegate (IntPtr arg1);

		static RefreshedVMDelegate RefreshedVMCallback;

		static void refreshed_cb (IntPtr arg1)
		{
			World arg1_managed = GLib.Object.GetObject (arg1, false) as World;
			arg1_managed.OnRefreshed ();
		}

		private static void OverrideRefreshed (GLib.GType gtype)
		{
			if (RefreshedVMCallback == null)
				RefreshedVMCallback = new RefreshedVMDelegate (refreshed_cb);
			OverrideVirtualMethod (gtype, "refreshed", RefreshedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(RC.World), ConnectionMethod="OverrideRefreshed")]
		protected virtual void OnRefreshed ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("refreshed")]
		public event System.EventHandler Refreshed {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "refreshed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "refreshed");
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libredcarpet")]
		static extern int rc_world_foreach_requiring_package(IntPtr raw, IntPtr dep, RCSharp.PackageAndDepDelegateNative fn, IntPtr user_data);

		public int ForeachRequiringPackage(RC.PackageDep dep, RC.PackageAndDepDelegate fn) {
			RCSharp.PackageAndDepDelegateWrapper fn_wrapper = new RCSharp.PackageAndDepDelegateWrapper (fn);
			int raw_ret = rc_world_foreach_requiring_package(Handle, dep == null ? IntPtr.Zero : dep.Handle, fn_wrapper.NativeDelegate, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern bool rc_world_package_is_locked(IntPtr raw, IntPtr package);

		public bool PackageIsLocked(RC.Package package) {
			bool raw_ret = rc_world_package_is_locked(Handle, package == null ? IntPtr.Zero : package.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = rc_world_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_get_channel_by_name(IntPtr raw, IntPtr channel_name);

		public RC.Channel GetChannelByName(string channel_name) {
			IntPtr channel_name_as_native = GLib.Marshaller.StringToPtrGStrdup (channel_name);
			IntPtr raw_ret = rc_world_get_channel_by_name(Handle, channel_name_as_native);
			RC.Channel ret = raw_ret == IntPtr.Zero ? null : (RC.Channel) GLib.Opaque.GetOpaque (raw_ret, typeof (RC.Channel), false);
			GLib.Marshaller.Free (channel_name_as_native);
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern int rc_world_foreach_lock(IntPtr raw, RCSharp.PackageMatchDelegateNative fn, IntPtr user_data);

		public int ForeachLock(RC.PackageMatchDelegate fn) {
			RCSharp.PackageMatchDelegateWrapper fn_wrapper = new RCSharp.PackageMatchDelegateWrapper (fn);
			int raw_ret = rc_world_foreach_lock(Handle, fn_wrapper.NativeDelegate, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern uint rc_world_get_channel_sequence_number(IntPtr raw);

		public uint ChannelSequenceNumber { 
			get {
				uint raw_ret = rc_world_get_channel_sequence_number(Handle);
				uint ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_guess_package_channel(IntPtr raw, IntPtr package);

		public RC.Channel GuessPackageChannel(RC.Package package) {
			IntPtr raw_ret = rc_world_guess_package_channel(Handle, package == null ? IntPtr.Zero : package.Handle);
			RC.Channel ret = raw_ret == IntPtr.Zero ? null : (RC.Channel) GLib.Opaque.GetOpaque (raw_ret, typeof (RC.Channel), false);
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_get_upgrades(IntPtr raw, IntPtr package, IntPtr channel);

		public RC.Package[] GetUpgrades(RC.Package package, RC.Channel channel) {
			IntPtr raw_ret = rc_world_get_upgrades(Handle, package == null ? IntPtr.Zero : package.Handle, channel == null ? IntPtr.Zero : channel.Handle);
			RC.Package[] ret = (RC.Package[]) GLib.Marshaller.ListToArray (new GLib.SList(raw_ret, typeof (RC.Package), false, false), typeof (RC.Package));
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern bool rc_world_is_subscribed(IntPtr raw, IntPtr channel);

		public bool IsSubscribed(RC.Channel channel) {
			bool raw_ret = rc_world_is_subscribed(Handle, channel == null ? IntPtr.Zero : channel.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern void rc_world_refresh_complete(IntPtr raw);

		public void RefreshComplete() {
			rc_world_refresh_complete(Handle);
		}

		[DllImport("libredcarpet")]
		static extern int rc_world_foreach_channel(IntPtr raw, RCSharp.ChannelDelegateNative fn, IntPtr user_data);

		public int ForeachChannel(RC.ChannelDelegate fn) {
			RCSharp.ChannelDelegateWrapper fn_wrapper = new RCSharp.ChannelDelegateWrapper (fn);
			int raw_ret = rc_world_foreach_channel(Handle, fn_wrapper.NativeDelegate, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern bool rc_world_has_refresh(IntPtr raw);

		public bool HasRefresh { 
			get {
				bool raw_ret = rc_world_has_refresh(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern int rc_world_foreach_providing_package(IntPtr raw, IntPtr dep, RCSharp.PackageAndSpecDelegateNative fn, IntPtr user_data);

		public int ForeachProvidingPackage(RC.PackageDep dep, RC.PackageAndSpecDelegate fn) {
			RCSharp.PackageAndSpecDelegateWrapper fn_wrapper = new RCSharp.PackageAndSpecDelegateWrapper (fn);
			int raw_ret = rc_world_foreach_providing_package(Handle, dep == null ? IntPtr.Zero : dep.Handle, fn_wrapper.NativeDelegate, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_get_channel_by_alias(IntPtr raw, IntPtr alias);

		public RC.Channel GetChannelByAlias(string alias) {
			IntPtr alias_as_native = GLib.Marshaller.StringToPtrGStrdup (alias);
			IntPtr raw_ret = rc_world_get_channel_by_alias(Handle, alias_as_native);
			RC.Channel ret = raw_ret == IntPtr.Zero ? null : (RC.Channel) GLib.Opaque.GetOpaque (raw_ret, typeof (RC.Channel), false);
			GLib.Marshaller.Free (alias_as_native);
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_get_package_with_constraint(IntPtr raw, IntPtr channel, IntPtr constraint, bool is_and);

		public RC.Package GetPackageWithConstraint(RC.Channel channel, RC.PackageDep constraint, bool is_and) {
			IntPtr raw_ret = rc_world_get_package_with_constraint(Handle, channel == null ? IntPtr.Zero : channel.Handle, constraint == null ? IntPtr.Zero : constraint.Handle, is_and);
			RC.Package ret = raw_ret == IntPtr.Zero ? null : (RC.Package) GLib.Opaque.GetOpaque (raw_ret, typeof (RC.Package), false);
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_get_package(IntPtr raw, IntPtr channel, IntPtr spec);

		public RC.Package GetPackage(RC.Channel channel, RC.PackageSpec spec) {
			IntPtr raw_ret = rc_world_get_package(Handle, channel == null ? IntPtr.Zero : channel.Handle, spec.Handle);
			RC.Package ret = raw_ret == IntPtr.Zero ? null : (RC.Package) GLib.Opaque.GetOpaque (raw_ret, typeof (RC.Package), false);
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern int rc_world_foreach_package(IntPtr raw, IntPtr channel, RCSharp.PackageDelegateNative fn, IntPtr user_data);

		public int ForeachPackage(RC.Channel channel, RC.PackageDelegate fn) {
			RCSharp.PackageDelegateWrapper fn_wrapper = new RCSharp.PackageDelegateWrapper (fn);
			int raw_ret = rc_world_foreach_package(Handle, channel == null ? IntPtr.Zero : channel.Handle, fn_wrapper.NativeDelegate, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern int rc_world_foreach_system_upgrade(IntPtr raw, bool subscribed_only, RCSharp.PackagePairDelegateNative fn, IntPtr user_data);

		public int ForeachSystemUpgrade(bool subscribed_only, RC.PackagePairDelegate fn) {
			RCSharp.PackagePairDelegateWrapper fn_wrapper = new RCSharp.PackagePairDelegateWrapper (fn);
			int raw_ret = rc_world_foreach_system_upgrade(Handle, subscribed_only, fn_wrapper.NativeDelegate, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern void rc_world_add_lock(IntPtr raw, IntPtr _lock);

		public void AddLock(RC.PackageMatch _lock) {
			rc_world_add_lock(Handle, _lock == null ? IntPtr.Zero : _lock.Handle);
		}

		[DllImport("libredcarpet")]
		static extern bool rc_world_contains_channel(IntPtr raw, IntPtr channel);

		public bool ContainsChannel(RC.Channel channel) {
			bool raw_ret = rc_world_contains_channel(Handle, channel == null ? IntPtr.Zero : channel.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern uint rc_world_get_package_sequence_number(IntPtr raw);

		public uint PackageSequenceNumber { 
			get {
				uint raw_ret = rc_world_get_package_sequence_number(Handle);
				uint ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern void rc_world_touch_channel_sequence_number(IntPtr raw);

		public void TouchChannelSequenceNumber() {
			rc_world_touch_channel_sequence_number(Handle);
		}

		[DllImport("libredcarpet")]
		static extern void rc_world_remove_lock(IntPtr raw, IntPtr _lock);

		public void RemoveLock(RC.PackageMatch _lock) {
			rc_world_remove_lock(Handle, _lock == null ? IntPtr.Zero : _lock.Handle);
		}

		[DllImport("libredcarpet")]
		static extern void rc_world_set_subscription(IntPtr raw, IntPtr channel, bool is_subscribed);

		public void SetSubscription(RC.Channel channel, bool is_subscribed) {
			rc_world_set_subscription(Handle, channel == null ? IntPtr.Zero : channel.Handle, is_subscribed);
		}

		[DllImport("libredcarpet")]
		static extern int rc_world_foreach_package_by_match(IntPtr raw, IntPtr match, RCSharp.PackageDelegateNative fn, IntPtr user_data);

		public int ForeachPackageByMatch(RC.PackageMatch match, RC.PackageDelegate fn) {
			RCSharp.PackageDelegateWrapper fn_wrapper = new RCSharp.PackageDelegateWrapper (fn);
			int raw_ret = rc_world_foreach_package_by_match(Handle, match == null ? IntPtr.Zero : match.Handle, fn_wrapper.NativeDelegate, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern void rc_world_touch_lock_sequence_number(IntPtr raw);

		public void TouchLockSequenceNumber() {
			rc_world_touch_lock_sequence_number(Handle);
		}

		[DllImport("libredcarpet")]
		static extern void rc_world_clear_locks(IntPtr raw);

		public void ClearLocks() {
			rc_world_clear_locks(Handle);
		}

		[DllImport("libredcarpet")]
		static extern bool rc_world_transact(IntPtr raw, IntPtr install_packages, IntPtr remove_packages, int flags);

		public bool Transact(GLib.SList install_packages, GLib.SList remove_packages, int flags) {
			bool raw_ret = rc_world_transact(Handle, install_packages.Handle, remove_packages.Handle, flags);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_refresh(IntPtr raw);

		public RC.Pending Refresh() {
			IntPtr raw_ret = rc_world_refresh(Handle);
			RC.Pending ret = GLib.Object.GetObject(raw_ret) as RC.Pending;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_get_locks(IntPtr raw);

		public RC.PackageMatch[] Locks { 
			get {
				IntPtr raw_ret = rc_world_get_locks(Handle);
				RC.PackageMatch[] ret = (RC.PackageMatch[]) GLib.Marshaller.ListToArray (new GLib.SList(raw_ret, typeof (RC.PackageMatch), false, false), typeof (RC.PackageMatch));
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_get_channels(IntPtr raw);

		public RC.Channel[] Channels { 
			get {
				IntPtr raw_ret = rc_world_get_channels(Handle);
				RC.Channel[] ret = (RC.Channel[]) GLib.Marshaller.ListToArray (new GLib.SList(raw_ret, typeof (RC.Channel), false, false), typeof (RC.Channel));
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern int rc_world_foreach_upgrade(IntPtr raw, IntPtr package, IntPtr channel, RCSharp.PackageDelegateNative fn, IntPtr user_data);

		public int ForeachUpgrade(RC.Package package, RC.Channel channel, RC.PackageDelegate fn) {
			RCSharp.PackageDelegateWrapper fn_wrapper = new RCSharp.PackageDelegateWrapper (fn);
			int raw_ret = rc_world_foreach_upgrade(Handle, package == null ? IntPtr.Zero : package.Handle, channel == null ? IntPtr.Zero : channel.Handle, fn_wrapper.NativeDelegate, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern bool rc_world_is_refreshing(IntPtr raw);

		public bool IsRefreshing { 
			get {
				bool raw_ret = rc_world_is_refreshing(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern void rc_world_touch_package_sequence_number(IntPtr raw);

		public void TouchPackageSequenceNumber() {
			rc_world_touch_package_sequence_number(Handle);
		}

		[DllImport("libredcarpet")]
		static extern int rc_world_foreach_conflicting_package(IntPtr raw, IntPtr dep, RCSharp.PackageAndDepDelegateNative fn, IntPtr user_data);

		public int ForeachConflictingPackage(RC.PackageDep dep, RC.PackageAndDepDelegate fn) {
			RCSharp.PackageAndDepDelegateWrapper fn_wrapper = new RCSharp.PackageAndDepDelegateWrapper (fn);
			int raw_ret = rc_world_foreach_conflicting_package(Handle, dep == null ? IntPtr.Zero : dep.Handle, fn_wrapper.NativeDelegate, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern uint rc_world_get_lock_sequence_number(IntPtr raw);

		public uint LockSequenceNumber { 
			get {
				uint raw_ret = rc_world_get_lock_sequence_number(Handle);
				uint ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_find_installed_version(IntPtr raw, IntPtr package);

		public RC.Package FindInstalledVersion(RC.Package package) {
			IntPtr raw_ret = rc_world_find_installed_version(Handle, package == null ? IntPtr.Zero : package.Handle);
			RC.Package ret = raw_ret == IntPtr.Zero ? null : (RC.Package) GLib.Opaque.GetOpaque (raw_ret, typeof (RC.Package), false);
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern int rc_world_foreach_parent_package(IntPtr raw, IntPtr dep, RCSharp.PackageAndDepDelegateNative fn, IntPtr user_data);

		public int ForeachParentPackage(RC.PackageDep dep, RC.PackageAndDepDelegate fn) {
			RCSharp.PackageAndDepDelegateWrapper fn_wrapper = new RCSharp.PackageAndDepDelegateWrapper (fn);
			int raw_ret = rc_world_foreach_parent_package(Handle, dep == null ? IntPtr.Zero : dep.Handle, fn_wrapper.NativeDelegate, IntPtr.Zero);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern uint rc_world_get_subscription_sequence_number(IntPtr raw);

		public uint SubscriptionSequenceNumber { 
			get {
				uint raw_ret = rc_world_get_subscription_sequence_number(Handle);
				uint ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern int rc_world_foreach_package_by_name(IntPtr raw, IntPtr name, IntPtr channel, RCSharp.PackageDelegateNative fn, IntPtr user_data);

		public int ForeachPackageByName(string name, RC.Channel channel, RC.PackageDelegate fn) {
			IntPtr name_as_native = GLib.Marshaller.StringToPtrGStrdup (name);
			RCSharp.PackageDelegateWrapper fn_wrapper = new RCSharp.PackageDelegateWrapper (fn);
			int raw_ret = rc_world_foreach_package_by_name(Handle, name_as_native, channel == null ? IntPtr.Zero : channel.Handle, fn_wrapper.NativeDelegate, IntPtr.Zero);
			int ret = raw_ret;
			GLib.Marshaller.Free (name_as_native);
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern bool rc_world_sync_conditional(IntPtr raw, IntPtr arg1);

		public bool SyncConditional(RC.Channel arg1) {
			bool raw_ret = rc_world_sync_conditional(Handle, arg1 == null ? IntPtr.Zero : arg1.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_dup(IntPtr raw);

		public RC.World Dup() {
			IntPtr raw_ret = rc_world_dup(Handle);
			RC.World ret = GLib.Object.GetObject(raw_ret) as RC.World;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_get_channel_by_id(IntPtr raw, IntPtr channel_id);

		public RC.Channel GetChannelById(string channel_id) {
			IntPtr channel_id_as_native = GLib.Marshaller.StringToPtrGStrdup (channel_id);
			IntPtr raw_ret = rc_world_get_channel_by_id(Handle, channel_id_as_native);
			RC.Channel ret = raw_ret == IntPtr.Zero ? null : (RC.Channel) GLib.Opaque.GetOpaque (raw_ret, typeof (RC.Channel), false);
			GLib.Marshaller.Free (channel_id_as_native);
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern bool rc_world_sync(IntPtr raw);

		public bool Sync() {
			bool raw_ret = rc_world_sync(Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern void rc_world_touch_subscription_sequence_number(IntPtr raw);

		public void TouchSubscriptionSequenceNumber() {
			rc_world_touch_subscription_sequence_number(Handle);
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_world_get_best_upgrade(IntPtr raw, IntPtr package, bool subscribed_only);

		public RC.Package GetBestUpgrade(RC.Package package, bool subscribed_only) {
			IntPtr raw_ret = rc_world_get_best_upgrade(Handle, package == null ? IntPtr.Zero : package.Handle, subscribed_only);
			RC.Package ret = raw_ret == IntPtr.Zero ? null : (RC.Package) GLib.Opaque.GetOpaque (raw_ret, typeof (RC.Package), false);
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern void rc_world_refresh_begin(IntPtr raw);

		public void RefreshBegin() {
			rc_world_refresh_begin(Handle);
		}

		[DllImport("libredcarpet")]
		static extern bool rc_world_can_transact_package(IntPtr raw, IntPtr package);

		public bool CanTransactPackage(RC.Package package) {
			bool raw_ret = rc_world_can_transact_package(Handle, package == null ? IntPtr.Zero : package.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern bool rc_world_get_single_provider(IntPtr raw, IntPtr dep, IntPtr channel, IntPtr package);

		public bool GetSingleProvider(RC.PackageDep dep, RC.Channel channel, RC.Package package) {
			bool raw_ret = rc_world_get_single_provider(Handle, dep == null ? IntPtr.Zero : dep.Handle, channel == null ? IntPtr.Zero : channel.Handle, package == null ? IntPtr.Zero : package.Handle);
			bool ret = raw_ret;
			return ret;
		}


		static World ()
		{
			GtkSharp.LibredcarpetSharp.ObjectManager.Initialize ();
		}
#endregion
#region Customized extensions
#line 1 "World.custom"
/* -*- Mode: csharp; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//{

    [DllImport("libredcarpet")]
    static extern IntPtr rc_get_world();

    [DllImport("libredcarpet")]
    static extern void rc_set_world(IntPtr world);

    public static RC.World Global { 
        get {
            IntPtr raw_ret = rc_get_world();
            RC.World ret;
            if (raw_ret == IntPtr.Zero)
                ret = null;
            else
                ret = (RC.World) GLib.Object.GetObject(raw_ret);
            return ret;
        }
        set {
            rc_set_world (value == null ? IntPtr.Zero : value.Handle);
        }
    }

    [DllImport("libredcarpet")]
    static extern void rc_world_set_refresh_function(IntPtr raw, RCSharp.WorldRefreshDelegateNative refresh_fn);

    public RC.WorldRefreshDelegate RefreshDelegate { 
        set {
            RCSharp.WorldRefreshDelegateWrapper value_wrapper = null;
            value_wrapper = new RCSharp.WorldRefreshDelegateWrapper (value);
            rc_world_set_refresh_function(Handle, value_wrapper.NativeDelegate);
        }
    }

    [DllImport("libredcarpet")]
    static extern IntPtr rc_query_part_new (IntPtr key, int type, IntPtr query_str);

    [DllImport("libredcarpet")]
    static extern void rc_query_part_free (IntPtr raw);

    [DllImport("libredcarpet")]
	static extern IntPtr rc_query_packages (IntPtr world, IntPtr query);

    public Package[] Query (params QueryPart[] queryParts) {
        // FIXME: Set owned and items owned correctly
        GLib.SList query = new GLib.SList (IntPtr.Zero, typeof (IntPtr));
        foreach (QueryPart part in queryParts) {
            IntPtr key_as_native = GLib.Marshaller.StringToPtrGStrdup (part.Key);
            IntPtr query_str_as_native = GLib.Marshaller.StringToPtrGStrdup (part.QueryStr);
            IntPtr rawPart = rc_query_part_new (key_as_native, (int) part.Type, query_str_as_native);
            GLib.Marshaller.Free (key_as_native);
            GLib.Marshaller.Free (query_str_as_native);

            query.Append (rawPart);
        }

        IntPtr raw_ret = rc_query_packages (Handle, query.Handle);

        foreach (IntPtr p in query)
            rc_query_part_free (p);

        query.Dispose ();
        return (RC.Package[]) GLib.Marshaller.ListToArray (new GLib.SList (raw_ret, typeof (RC.Package), false, false),
                                                           typeof (RC.Package));
    }

    public Package[] Query (string key, QueryType type, string queryStr) {
        return this.Query (new QueryPart (key, type, queryStr));
    }

    public Package[] Query (string key, string type, string queryStr) {
        return this.Query (new QueryPart (key, type, queryStr));
    }

    private class ToXmlHelper
    {
        private System.Xml.XmlTextWriter writer;
        private World world;

        public ToXmlHelper (World world, System.Xml.XmlTextWriter writer)
        {
            this.writer = writer;
        }

        public bool ForeachPackage (Package package)
        {
            package.ToXml (this.writer);

            return true;
        }

        public bool ForeachChannel (Channel channel)
        {
            /* These are handled by the "system_packages" section */
            if (channel.IsSystem)
                return true;

            channel.ToXml (this.writer);
            return true;
        }

        public bool ForeachLock (PackageMatch match)
        {
            match.ToXml (this.writer);
            return true;
        }
    }

    public void ToXml (System.Xml.XmlTextWriter writer)
    {
        ToXmlHelper helper = new ToXmlHelper (this, writer);

        writer.WriteStartElement ("system_packages");
        this.ForeachPackage (Channel.SYSTEM, new PackageDelegate (helper.ForeachPackage));
        writer.WriteEndElement ();

        this.ForeachChannel (new ChannelDelegate (helper.ForeachChannel));
    }

    public void ToXml (System.IO.Stream stream)
    {
        System.Xml.XmlTextWriter writer = new System.Xml.XmlTextWriter (stream, null);
        writer.WriteStartDocument ();
        writer.WriteStartElement ("world");

        writer.WriteStartElement ("locks");
        ToXmlHelper helper = new ToXmlHelper (this, writer);
        this.ForeachLock (new PackageMatchDelegate (helper.ForeachLock));
        writer.WriteEndElement ();

        this.ToXml (writer);

        writer.WriteEndElement ();
        writer.WriteEndDocument ();
        writer.Flush ();
    }

#endregion
	}
}
