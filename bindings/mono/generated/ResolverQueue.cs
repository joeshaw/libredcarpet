// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace RC {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class ResolverQueue : GLib.Opaque {

		[DllImport("libredcarpet")]
		static extern void rc_resolver_queue_add_package_to_remove(IntPtr raw, IntPtr package, bool remove_only_mode);

		public void AddPackageToRemove(RC.Package package, bool remove_only_mode) {
			rc_resolver_queue_add_package_to_remove(Handle, package.Handle, remove_only_mode);
		}

		[DllImport("libredcarpet")]
		static extern bool rc_resolver_queue_is_invalid(IntPtr raw);

		public bool IsInvalid { 
			get {
				bool raw_ret = rc_resolver_queue_is_invalid(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern void rc_resolver_queue_process(IntPtr raw);

		public void Process() {
			rc_resolver_queue_process(Handle);
		}

		[DllImport("libredcarpet")]
		static extern void rc_resolver_queue_add_package_to_install(IntPtr raw, IntPtr package);

		public void AddPackageToInstall(RC.Package package) {
			rc_resolver_queue_add_package_to_install(Handle, package.Handle);
		}

		[DllImport("libredcarpet")]
		static extern void rc_resolver_queue_split_first_branch(IntPtr raw, IntPtr new_queues, IntPtr deferred_queues);

		public void SplitFirstBranch(GLib.SList new_queues, GLib.SList deferred_queues) {
			rc_resolver_queue_split_first_branch(Handle, new_queues.Handle, deferred_queues.Handle);
		}

		[DllImport("libredcarpet")]
		static extern void rc_resolver_queue_add_item(IntPtr raw, ref RC.QueueItem item);

		public void AddItem(RC.QueueItem item) {
			rc_resolver_queue_add_item(Handle, ref item);
		}

		[DllImport("libredcarpet")]
		static extern bool rc_resolver_queue_contains_only_branches(IntPtr raw);

		public bool ContainsOnlyBranches() {
			bool raw_ret = rc_resolver_queue_contains_only_branches(Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern void rc_resolver_queue_add_package_to_verify(IntPtr raw, IntPtr package);

		public void AddPackageToVerify(RC.Package package) {
			rc_resolver_queue_add_package_to_verify(Handle, package.Handle);
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_resolver_queue_get_context(IntPtr raw);

		public RC.ResolverContext Context { 
			get {
				IntPtr raw_ret = rc_resolver_queue_get_context(Handle);
				RC.ResolverContext ret;
				if (raw_ret == IntPtr.Zero)
					ret = null;
				else
					ret = new RC.ResolverContext(raw_ret);
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern void rc_resolver_queue_free(IntPtr raw);

		public void Free() {
			rc_resolver_queue_free(Handle);
		}

		[DllImport("libredcarpet")]
		static extern bool rc_resolver_queue_process_once(IntPtr raw);

		public bool ProcessOnce() {
			bool raw_ret = rc_resolver_queue_process_once(Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libredcarpet")]
		static extern void rc_resolver_queue_add_extra_dependency(IntPtr raw, IntPtr dep);

		public void AddExtraDependency(RC.PackageDep dep) {
			rc_resolver_queue_add_extra_dependency(Handle, dep.Handle);
		}

		[DllImport("libredcarpet")]
		static extern void rc_resolver_queue_add_extra_conflict(IntPtr raw, IntPtr dep);

		public void AddExtraConflict(RC.PackageDep dep) {
			rc_resolver_queue_add_extra_conflict(Handle, dep.Handle);
		}

		[DllImport("libredcarpet")]
		static extern bool rc_resolver_queue_is_empty(IntPtr raw);

		public bool IsEmpty { 
			get {
				bool raw_ret = rc_resolver_queue_is_empty(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libredcarpet")]
		static extern void rc_resolver_queue_spew(IntPtr raw);

		public void Spew() {
			rc_resolver_queue_spew(Handle);
		}

		public ResolverQueue(IntPtr raw) : base(raw) {}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_resolver_queue_new();

		public ResolverQueue () 
		{
			Raw = rc_resolver_queue_new();
		}

		[DllImport("libredcarpet")]
		static extern IntPtr rc_resolver_queue_new_with_context(IntPtr arg1);

		public ResolverQueue (RC.ResolverContext arg1) 
		{
			Raw = rc_resolver_queue_new_with_context(arg1.Handle);
		}

#endregion
	}
}
